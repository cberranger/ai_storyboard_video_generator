"""Custom ComfyUI nodes wrapping the storyboard generation scripts.

Each node calls one of the existing Python scripts in this
repository and returns the path to the file generated by that script.
The intent is to allow the entire story pipeline to be executed from a
single ComfyUI workflow.
"""

from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Tuple

# ---------------------------------------------------------------------------
# Helper utilities
# ---------------------------------------------------------------------------

def _run_script(script: str) -> None:
    """Execute a Python script located in the repository root."""
    subprocess.run(["python", script], check=True)


def _latest_file(directory: str, suffix: str) -> str:
    """Return the most recently modified file with the given suffix."""
    path = Path(directory)
    files = sorted(path.glob(f"*{suffix}"), key=lambda p: p.stat().st_mtime, reverse=True)
    if not files:
        raise FileNotFoundError(f"No files ending with {suffix} found in {directory}")
    return str(files[0])


# ---------------------------------------------------------------------------
# Node implementations
# ---------------------------------------------------------------------------


class DreamUpStoryNode:
    """Run ``1_dream_up_a_story.py`` and return the resulting JSON path."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self) -> Tuple[str]:
        _run_script("1_dream_up_a_story.py")
        json_path = _latest_file("storylines", "_story.json")
        return (json_path,)


class BuildChaptersNode:
    """Run ``2_build_out_chapters.py`` using the given story JSON."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"story_json": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, story_json: str) -> Tuple[str]:
        _run_script("2_build_out_chapters.py")
        # The script updates the same JSON file
        return (story_json,)


class SummarizeChaptersNode:
    """Run ``3_summarize_chapters_add_ai_prompts.py``."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"story_json": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, story_json: str) -> Tuple[str]:
        _run_script("3_summarize_chapters_add_ai_prompts.py")
        summarized = _latest_file("storylines", "_summaries.json")
        return (summarized,)


class CreateImagesNode:
    """Run ``4_create_images_from_ai_prompts.py`` and return image folder."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"summary_json": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, summary_json: str) -> Tuple[str]:
        _run_script("4_create_images_from_ai_prompts.py")
        return ("generated_images",)


class CreateUniqueCharacterNode:
    """Run ``4b_unique_character.py`` and return generated image folder."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"summary_json": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, summary_json: str) -> Tuple[str]:
        _run_script("4b_unique_character.py")
        return ("generated_images",)


class CreateMovieNode:
    """Run ``5_create_movie.py`` and return the movie file path."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"image_dir": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, image_dir: str) -> Tuple[str]:
        _run_script("5_create_movie.py")
        movie_path = _latest_file(".", ".mp4")
        return (movie_path,)


class CreateMosaicNode:
    """Run ``6_create_mosaic.py`` to build a mosaic movie."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"movie_path": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, movie_path: str) -> Tuple[str]:
        _run_script("6_create_mosaic.py")
        mosaic = _latest_file(".", "_mosaic.mp4")
        return (mosaic,)


class ZoomPanMovieNode:
    """Run ``7_zoompan_movie.py`` to add motion effects."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"mosaic_path": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, mosaic_path: str) -> Tuple[str]:
        _run_script("7_zoompan_movie.py")
        zoomed = _latest_file(".", "_zoompan.mp4")
        return (zoomed,)


class AddSubtitlesNode:
    """Run ``8_add_ffmpeg_subtitles.py`` to embed subtitles."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"video_path": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, video_path: str) -> Tuple[str]:
        _run_script("8_add_ffmpeg_subtitles.py")
        subtitled = _latest_file(".", "_subtitled.mp4")
        return (subtitled,)


class CreateVoiceoverNode:
    """Run ``9_create_voiceover.py`` and return the audio path."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"summary_json": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, summary_json: str) -> Tuple[str]:
        _run_script("9_create_voiceover.py")
        audio = _latest_file(".", ".mp3")
        return (audio,)


class PreviewAndUploadNode:
    """Run ``0_preview_mosaics_then_upload_to_youtube.py``."""

    @classmethod
    def INPUT_TYPES(cls):
        return {"required": {"video_path": ("STRING",)}}

    RETURN_TYPES = ("STRING",)
    FUNCTION = "run"
    CATEGORY = "StoryPipeline"

    def run(self, video_path: str) -> Tuple[str]:
        _run_script("0_preview_mosaics_then_upload_to_youtube.py")
        # Script handles preview/upload, return original path
        return (video_path,)
